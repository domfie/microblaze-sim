# Copyright (c) 2003-2010,  Pete Sanderson and Kenneth Vollmar
#
# Developed by Pete Sanderson (psanderson@otterbein.edu)
# and Kenneth Vollmar (kenvollmar@missouristate.edu)
#
# Permission is hereby granted, free of charge, to any person obtaining 
# a copy of this software and associated documentation files (the 
# "Software"), to deal in the Software without restriction, including 
# without limitation the rights to use, copy, modify, merge, publish, 
# distribute, sublicense, and/or sell copies of the Software, and to 
# permit persons to whom the Software is furnished to do so, subject 
# to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# (MIT license, http://www.opensource.org/licenses/mit-license.html)


# File containing definitions of MIPS pseudo-ops

# File format:
#   Each line contains specification for one pseudo-op, including optional description.
#   First item is source statement syntax, specified in same "example" parser format used for regular instructions.
#   Source statement specification ends with a tab.  It is followed by a tab-separated list of basic instruction
#   templates to complete and substitute for the pseudo-op.
#   Format for specifying syntax of templates is different from specifying syntax of source statement:
#      (n=0,1,2,3,...) is token position in source statement (operator is token 0, parentheses are tokens but commas aren't)
#      RGn means substitute register found in n'th token of source statement
#      NRn means substitute next higher register than the one in n'th token of source code
#      OPn means substitute n'th token of source code as is
#      LLn means substitute low order 16-bits from label address in source token n.
#      LLnU means substitute low order 16-bits (unsigned) from label address in source token n.
#      LLnPm (m=1,2,3,4) means substitute low order 16-bits from label address in source token n, after adding m.
#      LHn means substitute high order 16-bits from label address in source token n. Must add 1 if address bit 15 is 1. 
#      LHnPm (m=1,2,3,4) means substitute high order 16-bits from label address in source token n, after adding m. Must then add 1 if bit 15 is 1. 
#      VLn means substitute low order 16-bits from 32-bit value in source token n.
#      VLnU means substitute low order 16-bits (unsigned) from 32-bit value in source token n.
#      VLnPm (m=1,2,3,4) means substitute low order 16-bits from 32-bit value in source token n, after adding m to value.
#      VLnPmU (m=1,2,3,4) means substitute low order 16-bits(unsigned) from 32-bit value in source token n, after adding m to value.
#      VHLn means substitute high order 16-bits from 32-bit value in source token n.  Use this if later combined with low order 16-bits using "ori R1,R1,VLnU". See logical and branch operations.
#      VHn means substitute high order 16-bits from 32-bit value in source token n, then add 1 if value's bit 15 is 1.  Use this only if later instruction uses VLn(R1) to calculate 32-bit address.  See loads and stores.
#      VHLnPm (m=1,2,3,4) means substitute high order 16-bits from 32-bit value in source token n, after adding m.  See VHLn.
#      VHnPm (m=1,2,3,4) means substitute high order 16-bits from 32-bit value in source token n, after adding m. Must then add 1 if bit 15 is 1. See VHn.
#      LLP is similar to LLn, but is needed for "label+100000" address offset. Immediate is added before taking low order 16. 
#      LLPU is similar to LLn, but is needed for "label+100000" address offset. Immediate is added before taking low order 16 (unsigned). 
#      LLPPm (m=1,2,3,4) is similar to LLP except m is added along with immediate before taking low order 16. 
#      LHPA is similar to LHn, but is needed for "label+100000" address offset. Immediate is added before taking high order 16.
#      LHPN is similar to LHPA, used only by "la" instruction. Address resolved by "ori" so do not add 1 if bit 15 is 1.
#      LHPAPm (m=1,2,3,4) is similar to LHPA except value m is added along with immediate before taking high order 16.
#      LHL means substitute high order 16-bits from label address in token 2 of "la" (load address) source statement.
#      LAB means substitute textual label from last token of source statement.  Used for various branches.
#      S32 means substitute the result of subtracting the constant value in last token from 32.  Used by "ror", "rol".
#      DBNOP means Delayed Branching NOP - generate a "nop" instruction but only if delayed branching is enabled.  Added in 3.4.1 release.
#      BROFFnm means substitute n if delayed branching is NOT enabled otherwise substitute m.  n and m are single digit numbers indicating constant branch offset (in words).  Added in 3.4.1 release.
#      COMPACT is a marker to separate the default template from a second template optimized for 16-bit addresses.  See loads and stores having (data) label operands.
#   Everything else is copied as is into the generated statement (you must use register numbers not mnemonics)
#   The list of basic instruction templates is optionally followed a description of the instruction for help purposes.
#   To add optional description, append a tab then the '#' character followed immediately (no spaces) by the description.
#
#  See documentation for ExtendedInstruction.makeTemplateSubstitutions() for more details.
#
#  Matching for a given instruction mnemonic is first-fit not best-fit.  If an instruction has both 16 and 32-bit
#  immediate operand options, they should be listed in that order (16-bit version first).  Otherwise the 16-bit
#  version will never be matched since the 32-bit version fits small immediate values first.
#
#  The pseudo-op specification must start in the first column.  If first column is blank, the line will be skipped!
#
#  When specifying the example instruction (first item on line), the conventions I follow are:
#  - for a register operand, specify a numbered register (e.g. Rt1 or Rf1) to represent any register in the set. 
#    The numerical value is not significant.  This is NOT the case when writing the templates that follow!
#    In the templates, numbered registers are parsed as is (use only R0 and R1, which are Rzero and Rat).
#  - for an immediate operand, specify a positive value indicative of the expected range.  I use 10 to represent
#    a 5 bit value, 100 to represent a 16-bit value, and 100000 to represent a 32-bit value.
#  - for a label operand, I use the string "label" (without the quotes). 
#  The idea is to give the parser an example that will be parsed into the desired token sequence.  Syntax checking
#  is done by comparing the source token sequence to list of token sequences generated from the examples.
#  IMPORTANT NOTE:  The use of Rt1,Rt2, etc in the instruction sample means that any CPU register reference
#                   can be used in that position.  It is simply a placeholder.  By contrast, when
#                   R1 is used in the template specification, R1 (Rat) is literally placed into the generated
#                   instruction!  If you want the generated code to echo the source register, use RG1,RG2, etc.

#######################  arithmetic and branch pseudo-ops #####################

not Rt1,Rt2	nor RG1, RG2, R0	#Bitwise NOT (bit inversion)

# Here are some "convenience" arithmetic pseduo-ops.  But do they encourage sloppy programming?
add Rt1,Rt2,-100	addi RG1, RG2, VL3	#ADDition : set Rt1 to (Rt2 plus 16-bit immediate)
add Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	add RG1, RG2, R1	#ADDition : set Rt1 to (Rt2 plus 32-bit immediate)
addu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	addu RG1, RG2, R1	#ADDition Unsigned : set Rt1 to (Rt2 plus 32-bit immediate), no overflow
addi Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	add RG1, RG2, R1	#ADDition Immediate : set Rt1 to (Rt2 plus 32-bit immediate)
addiu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	addu RG1, RG2, R1	#ADDition Immediate Unsigned: set Rt1 to (Rt2 plus 32-bit immediate), no overflow
sub Rt1,Rt2,-100		addi R1, R0, VL3	sub RG1, RG2, R1	#SUBtraction : set Rt1 to (Rt2 minus 16-bit immediate)
sub Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	sub RG1, RG2, R1	#SUBtraction : set Rt1 to (Rt2 minus 32-bit immediate)
subu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	subu RG1, RG2, R1	#SUBtraction Unsigned : set Rt1 to (Rt2 minus 32-bit immediate), no overflow
subi Rt1,Rt2,-100		addi R1, R0, VL3	sub RG1, RG2, R1	#SUBtraction Immediate : set Rt1 to (Rt2 minus 16-bit immediate)
subi Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	sub RG1, RG2, R1	#SUBtraction Immediate : set Rt1 to (Rt2 minus 32-bit immediate)
subiu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	subu RG1, RG2, R1	#SUBtraction Immediate Unsigned : set Rt1 to (Rt2 minus 32-bit immediate), no overflow
# feel free to add more convenience arithmetic pseduo-ops.

# convenience logical operations can be added too,
andi Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	and RG1, RG2, R1	#AND Immediate : set Rt1 to (Rt2 bitwise-AND 32-bit immediate)
ori Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	or RG1, RG2, R1		#OR Immediate : set Rt1 to (Rt2 bitwise-OR 32-bit immediate)
xori Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	xor RG1, RG2, R1	#XOR Immediate : set Rt1 to (Rt2 bitwise-exclusive-OR 32-bit immediate)
and Rt1,Rt2,100	andi RG1, RG2, VL3U	#AND : set Rt1 to (Rt2 bitwise-AND 16-bit unsigned immediate)
or Rt1,Rt2,100	ori RG1, RG2, VL3U	#OR : set Rt1 to (Rt2 bitwise-OR 16-bit unsigned immediate)
xor Rt1,Rt2,100	xori RG1, RG2, VL3U	#XOR : set Rt1 to (Rt2 bitwise-exclusive-OR 16-bit unsigned immediate)
and Rt1,100	andi RG1, RG1, VL2U	#AND : set Rt1 to (Rt1 bitwise-AND 16-bit unsigned immediate)
or Rt1,100	ori RG1, RG1, VL2U	#OR : set Rt1 to (Rt1 bitwise-OR 16-bit unsigned immediate)
xor Rt1,100	xori RG1, RG1, VL2U	#XOR : set Rt1 to (Rt1 bitwise-exclusive-OR 16-bit unsigned immediate)
andi Rt1,100	andi RG1, RG1, VL2U	#AND Immediate : set Rt1 to (Rt1 bitwise-AND 16-bit unsigned immediate)
ori Rt1,100	ori RG1, RG1, VL2U	#OR Immediate : set Rt1 to (Rt1 bitwise-OR 16-bit unsigned immediate)
xori Rt1,100	xori RG1, RG1, VL2U	#XOR Immediate : set Rt1 to (Rt1 bitwise-exclusive-OR 16-bit unsigned immediate)
andi Rt1,100000	lui R1, VHL2	ori R1, R1, VL2U	and RG1, RG1, R1	#AND Immediate : set Rt1 to (Rt1 bitwise-AND 32-bit immediate)
ori Rt1,100000	lui R1, VHL2	ori R1, R1, VL2U	or RG1, RG1, R1	#OR Immediate : set Rt1 to (Rt1 bitwise-OR 32-bit immediate)
xori Rt1,100000	lui R1, VHL2	ori R1, R1, VL2U	xor RG1, RG1, R1	#XOR Immediate : set Rt1 to (Rt1 bitwise-exclusive-OR 32-bit immediate)

# Note: most of the expansions in this group were rewritten for Release 3.4.1 to remove internal branching.
seq Rt1,Rt2,Rt3	subu RG1, RG2, RG3	ori R1, R0, 1	sltu RG1, RG1, R1	#Set EQual : if Rt2 equal to Rt3 then set Rt1 to 1 else 0
seq Rt1,Rt2,-100	addi R1, R0, VL3	subu RG1, RG2, R1	ori R1, R0, 1	sltu RG1, RG1, R1	#Set EQual : if Rt2 equal to 16-bit immediate then set Rt1 to 1 else 0
seq Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	subu RG1, RG2, R1	ori R1, R0, 1	sltu RG1, RG1, R1	#Set EQual : if Rt2 equal to 32-bit immediate then set Rt1 to 1 else 0

sne Rt1,Rt2,Rt3	subu RG1, RG2, RG3	sltu RG1, R0, RG1	#Set Not Equal : if Rt2 not equal to Rt3 then set Rt1 to 1 else 0
sne Rt1,Rt2,-100	addi R1, R0, VL3	subu RG1, RG2, R1	sltu RG1, R0, RG1	#Set Not Equal : if Rt2 not equal to 16-bit immediate then set Rt1 to 1 else 0
sne Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	subu RG1, RG2, R1	sltu RG1, R0, RG1	#Set Not Equal : if Rt2 not equal to 32-bit immediate then set Rt1 to 1 else 0

sge Rt1,Rt2,Rt3	slt RG1, RG2, RG3	ori R1, R0, 1	subu RG1, R1, RG1	#Set Greater or Equal : if Rt2 greater or equal to Rt3 then set Rt1 to 1 else 0
sge Rt1,Rt2,-100	addi R1, R0, VL3	slt RG1, RG2, R1	ori R1, R0, 1	subu RG1, R1, RG1	#Set Greater or Equal : if Rt2 greater or equal to 16-bit immediate then set Rt1 to 1 else 0
sge Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	slt RG1, RG2, R1	ori R1, R0, 1	subu RG1, R1, RG1	#Set Greater or Equal : if Rt2 greater or equal to 32-bit immediate then set Rt1 to 1 else 0

sgeu Rt1,Rt2,Rt3	sltu RG1, RG2, RG3	ori R1, R0, 1	subu RG1, R1, RG1	#Set Greater or Equal Unsigned : if Rt2 greater or equal to Rt3 (unsigned compare) then set Rt1 to 1 else 0
sgeu Rt1,Rt2,-100	addi R1, R0, VL3	sltu RG1, RG2, R1	ori R1, R0, 1	subu RG1, R1, RG1	#Set Greater or Equal Unsigned : if Rt2 greater or equal to 16-bit immediate (unsigned compare) then set Rt1 to 1 else 0
sgeu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	sltu RG1, RG2, R1	ori R1, R0, 1	subu RG1, R1, RG1	#Set Greater or Equal Unsigned : if Rt2 greater or equal to 32-bit immediate (unsigned compare) then set Rt1 to 1 else 0

sgt Rt1,Rt2,Rt3	slt RG1, RG3, RG2	#Set Greater Than : if Rt2 greater than Rt3 then set Rt1 to 1 else 0
sgt Rt1,Rt2,-100	addi R1, R0, VL3	slt RG1, R1, RG2	#Set Greater Than : if Rt2 greater than 16-bit immediate then set Rt1 to 1 else 0
sgt Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	slt RG1, R1, RG2	#Set Greater Than : if Rt2 greater than 32-bit immediate then set Rt1 to 1 else 0

sgtu Rt1,Rt2,Rt3	sltu RG1, RG3, RG2	#Set Greater Than Unsigned : if Rt2 greater than Rt3 (unsigned compare) then set Rt1 to 1 else 0
sgtu Rt1,Rt2,-100	addi R1, R0, VL3	sltu RG1, R1, RG2	#Set Greater Than Unsigned : if Rt2 greater than 16-bit immediate (unsigned compare) then set Rt1 to 1 else 0
sgtu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	sltu RG1, R1, RG2	#Set Greater Than Unsigned : if Rt2 greater than 32-bit immediate (unsigned compare) then set Rt1 to 1 else 0

sle Rt1,Rt2,Rt3	slt RG1, RG3, RG2	ori R1, R0, 1	subu RG1, R1, RG1	#Set Less or Equal : if Rt2 less or equal to Rt3 then set Rt1 to 1 else 0
sle Rt1,Rt2,-100	addi R1, R0, VL3	slt RG1, R1, RG2	ori R1, R0, 1	subu RG1, R1, RG1	#Set Less or Equal : if Rt2 less or equal to 16-bit immediate then set Rt1 to 1 else 0
sle Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	slt RG1, R1, RG2	ori R1, R0, 1	subu RG1, R1, RG1	#Set Less or Equal : if Rt2 less or equal to 32-bit immediate then set Rt1 to 1 else 0

sleu Rt1,Rt2,Rt3	sltu RG1, RG3, RG2	ori R1, R0, 1	subu RG1, R1, RG1	#Set Less or Equal Unsigned: if Rt2 less or equal to Rt3 (unsigned compare) then set Rt1 to 1 else 0
sleu Rt1,Rt2,-100	addi R1, R0, VL3	sltu RG1, R1, RG2	ori R1, R0, 1	subu RG1, R1, RG1	#Set Less or Equal Unsigned: if Rt2 less or equal to 16-bit immediate (unsigned compare) then set Rt1 to 1 else 0
sleu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	sltu RG1, R1, RG2	ori R1, R0, 1	subu RG1, R1, RG1	#Set Less or Equal Unsigned: if Rt2 less or equal to 32-bit immediate (unsigned compare) then set Rt1 to 1 else 0


move Rt1,Rt2	addu RG1, R0, RG2	#MOVE : Set Rt1 to contents of Rt2
abs Rt1,Rt2	sra R1, RG2, 31	xor RG1, R1, RG2	subu RG1, RG1, R1	#ABSolute value : Set Rt1 to absolute value of Rt2 (algorithm from Hacker's Delight) 
neg Rt1,Rt2	sub RG1, R0, RG2	#NEGate : Set Rt1 to negation of Rt2
negu Rt1,Rt2	subu RG1, R0, RG2	#NEGate Unsigned : Set Rt1 to negation of Rt2, no overflow

b label	bgez R0, LAB	#Branch : Branch to statement at label unconditionally
beqz Rt1,label	beq RG1, R0, LAB	#Branch if EQual Zero : Branch to statement at label if Rt1 is equal to zero
bnez Rt1,label	bne RG1, R0, LAB	#Branch if Not Equal Zero : Branch to statement at label if Rt1 is not equal to zero

beq Rt1,-100,label	addi R1, R0, VL2	beq R1, RG1, LAB	#Branch if EQual : Branch to statement at label if Rt1 is equal to 16-bit immediate
beq Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	beq R1, RG1, LAB	#Branch if EQual : Branch to statement at label if Rt1 is equal to 32-bit immediate	
bne Rt1,-100,label	addi R1, R0, VL2	bne R1, RG1, LAB	#Branch if Not Equal : Branch to statement at label if Rt1 is not equal to 16-bit immediate
bne Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	bne R1, RG1, LAB	#Branch if Not Equal : Branch to statement at label if Rt1 is not equal to 32-bit immediate	

bge Rt1,Rt2,label	slt R1, RG1, RG2	beq R1, R0, LAB	#Branch if Greater or Equal : Branch to statement at label if Rt1 is greater or equal to Rt2
bge Rt1,-100,label	slti R1, RG1, VL2	beq R1, R0, LAB	#Branch if Greater or Equal : Branch to statement at label if Rt1 is greater or equal to 16-bit immediate	
bge Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	slt R1, RG1, R1	beq R1, R0, LAB	#Branch if Greater or Equal : Branch to statement at label if Rt1 is greater or equal to 32-bit immediate	

bgeu Rt1,Rt2,label	sltu R1, RG1, RG2	beq R1, R0, LAB	#Branch if Greater or Equal Unsigned : Branch to statement at label if Rt1 is greater or equal to Rt2 (unsigned compare)
bgeu Rt1,-100,label	sltiu R1, RG1, VL2	beq R1, R0, LAB	#Branch if Greater or Equal Unsigned : Branch to statement at label if Rt1 is greater or equal to 16-bit immediate (unsigned compare)
bgeu Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	sltu R1, RG1, R1	beq R1, R0, LAB	#Branch if Greater or Equal Unsigned : Branch to statement at label if Rt1 is greater or equal to 32-bit immediate (unsigned compare)

bgt Rt1,Rt2,label	slt R1, RG2, RG1	bne R1, R0, LAB	#Branch if Greater Than : Branch to statement at label if Rt1 is greater than Rt2
bgt Rt1,-100,label	addi R1, R0, VL2	slt R1, R1, RG1	bne R1, R0, LAB	#Branch if Greater Than : Branch to statement at label if Rt1 is greater than 16-bit immediate	
bgt Rt1,100000,label	lui R1, VHL2P1	ori R1, R1, VL2P1U	slt R1, RG1, R1	beq R1, R0, LAB	#Branch if Greater Than : Branch to statement at label if Rt1 is greater than 32-bit immediate

bgtu Rt1,Rt2,label	sltu R1, RG2, RG1	bne R1, R0, LAB	#Branch if Greater Than Unsigned: Branch to statement at label if Rt1 is greater than Rt2 (unsigned compare)
bgtu Rt1,-100,label	addi R1, R0, VL2	sltu R1, R1, RG1	bne R1, R0, LAB	#Branch if Greater Than Unsigned: Branch to statement at label if Rt1 is greater than 16-bit immediate (unsigned compare)
bgtu Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	sltu R1, R1, RG1	bne R1, R0, LAB	#Branch if Greater Than Unsigned: Branch to statement at label if Rt1 is greater than 16-bit immediate (unsigned compare)

ble Rt1,Rt2,label	slt R1, RG2, RG1	beq R1, R0, LAB	#Branch if Less or Equal : Branch to statement at label if Rt1 is less than or equal to Rt2
ble Rt1,-100,label	addi R1, RG1, -1	slti R1, R1, VL2	bne R1, R0, LAB	#Branch if Less or Equal : Branch to statement at label if Rt1 is less than or equal to 16-bit immediate
ble Rt1,100000,label	lui R1, VHL2P1	ori R1, R1, VL2P1U	slt R1, RG1, R1	bne R1, R0, LAB	#Branch if Less or Equal : Branch to statement at label if Rt1 is less than or equal to 32-bit immediate	

bleu Rt1,Rt2,label	sltu R1, RG2, RG1	beq R1, R0, LAB	#Branch if Less or Equal Unsigned : Branch to statement at label if Rt1 is less than or equal to Rt2 (unsigned compare)
bleu Rt1,-100,label	addi R1, R0, VL2	sltu R1, R1, RG1	beq R1, R0, LAB	#Branch if Less or Equal Unsigned : Branch to statement at label if Rt1 is less than or equal to 16-bit immediate (unsigned compare)
bleu Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	sltu R1, R1, RG1	beq R1, R0, LAB	#Branch if Less or Equal Unsigned : Branch to statement at label if Rt1 is less than or equal to 32-bit immediate (unsigned compare)

blt Rt1,Rt2,label	slt R1, RG1, RG2	bne R1, R0, LAB	#Branch if Less Than : Branch to statement at label if Rt1 is less than Rt2
blt Rt1,-100,label	slti R1, RG1, VL2	bne R1, R0, LAB	#Branch if Less Than : Branch to statement at label if Rt1 is less than 16-bit immediate
blt Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	slt R1, RG1, R1	bne R1, R0, LAB	#Branch if Less Than : Branch to statement at label if Rt1 is less than 32-bit immediate

bltu Rt1,Rt2,label	sltu R1, RG1, RG2	bne R1, R0, LAB	#Branch if Less Than Unsigned : Branch to statement at label if Rt1 is less than Rt2
bltu Rt1,-100,label	sltiu R1, RG1, VL2	bne R1, R0, LAB	#Branch if Less Than Unsigned : Branch to statement at label if Rt1 is less than 16-bit immediate	
bltu Rt1,100000,label	lui R1, VHL2	ori R1, R1, VL2U	sltu R1, RG1, R1	bne R1, R0, LAB	#Branch if Less Than Unsigned : Branch to statement at label if Rt1 is less than 32-bit immediate

rol Rt1,Rt2,Rt3	subu R1, R0, RG3	srlv R1, RG2, R1	sllv RG1, RG2, RG3	or RG1, RG1, R1	#ROtate Left : Set Rt1 to (Rt2 rotated left by number of bit positions specified in Rt3)
rol Rt1,Rt2,10	srl R1, RG2, S32	sll RG1, RG2, OP3	or RG1, RG1, R1	#ROtate Left : Set Rt1 to (Rt2 rotated left by number of bit positions specified in 5-bit immediate)
ror Rt1,Rt2,Rt3	subu R1, R0, RG3	sllv R1, RG2, R1	srlv RG1, RG2, RG3	or RG1, RG1, R1	#ROtate Right : Set Rt1 to (Rt2 rotated right by number of bit positions specified in Rt3)
ror Rt1,Rt2,10	sll R1, RG2, S32	srl RG1, RG2, OP3	or RG1, RG1, R1	#ROtate Right : Set Rt1 to (Rt2 rotated right by number of bit positions specified in 5-bit immediate)

mfc1.d Rt1,Rf2	mfc1 RG1, RG2	mfc1 NR1, NR2	#Move From Coprocessor 1 Double : Set Rt1 to contents of Rf2, set next higher register from Rt1 to contents of next higher register from Rf2
mtc1.d Rt1,Rf2	mtc1 RG1, RG2	mtc1 NR1, NR2	#Move To Coprocessor 1 Double : Set Rf2 to contents of Rt1, set next higher register from Rf2 to contents of next higher register from Rt1

mul Rt1,Rt2,-100	addi R1, R0, VL3	mul RG1, RG2, R1	#MULtiplication : Set HI to high-order 32 bits, LO and Rt1 to low-order 32 bits of the product of Rt2 and 16-bit signed immediate (use mfhi to access HI, mflo to access LO)
mul Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	mul RG1, RG2, R1	#MULtiplication : Set HI to high-order 32 bits, LO and Rt1 to low-order 32 bits of the product of Rt2 and 32-bit immediate (use mfhi to access HI, mflo to access LO)
mulu Rt1,Rt2,Rt3	multu RG2, RG3	mflo RG1	#MULtiplication Unsigned : Set HI to high-order 32 bits, LO and Rt1 to low-order 32 bits of (Rt2 multiplied by Rt3, unsigned multiplication)
mulu Rt1,Rt2,-100	addi R1, R0, VL3	multu RG2, R1	mflo RG1	#MULtiplication Unsigned :  Set HI to high-order 32 bits, LO and Rt1 to low-order 32 bits of (Rt2 multiplied by 16-bit immediate, unsigned multiplication)
mulu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	multu RG2, R1	mflo RG1	#MULtiplication Unsigned :  Set HI to high-order 32 bits, LO and Rt1 to low-order 32 bits of (Rt2 multiplied by 32-bit immediate, unsigned multiplication)
mulo Rt1,Rt2,Rt3	mult RG2, RG3	mfhi R1	mflo RG1	sra RG1, RG1, 31	beq R1, RG1, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow : Set Rt1 to low-order 32 bits of the product of Rt2 and Rt3
mulo Rt1,Rt2,-100	addi R1, R0, VL3	mult RG2, R1	mfhi R1	mflo RG1	sra RG1, RG1, 31	beq R1, RG1, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow : Set Rt1 to low-order 32 bits of the product of Rt2 and signed 16-bit immediate
mulo Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	mult RG2, R1	mfhi R1	mflo RG1	sra RG1, RG1, 31	beq R1, RG1, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow : Set Rt1 to low-order 32 bits of the product of Rt2 and 32-bit immediate
mulou Rt1,Rt2,Rt3	multu RG2, RG3	mfhi R1	beq R1,R0, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow Unsigned : Set Rt1 to low-order 32 bits of the product of Rt2 and Rt3
mulou Rt1,Rt2,-100	addi R1, R0, VL3	multu RG2, R1	mfhi R1	beq R1,R0, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow Unsigned : Set Rt1 to low-order 32 bits of the product of Rt2 and signed 16-bit immediate
mulou Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	multu RG2, R1	mfhi R1	beq R1,R0, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow Unsigned : Set Rt1 to low-order 32 bits of the product of Rt2 and 32-bit immediate
div Rt1,Rt2,Rt3	bne RG3, R0, BROFF12	DBNOP	break	div RG2, RG3	mflo RG1	#DIVision : Set Rt1 to (Rt2 divided by Rt3, integer division)
div Rt1,Rt2,-100	addi R1, R0, VL3	div RG2, R1	mflo RG1	#DIVision : Set Rt1 to (Rt2 divided by 16-bit immediate, integer division)
div Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	div RG2, R1	mflo RG1	#DIVision : Set Rt1 to (Rt2 divided by 32-bit immediate, integer division)
divu Rt1,Rt2,Rt3	bne RG3, R0, BROFF12	DBNOP	break	divu RG2, RG3	mflo RG1	#DIVision Unsigned :  Set Rt1 to (Rt2 divided by Rt3, unsigned integer division)
divu Rt1,Rt2,-100	addi R1, R0, VL3	divu RG2, R1	mflo RG1	#DIVision Unsigned :  Set Rt1 to (Rt2 divided by 16-bit immediate, unsigned integer division)
divu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	divu RG2, R1	mflo RG1	#DIVision Unsigned :  Set Rt1 to (Rt2 divided by 32-bit immediate, unsigned integer division)
rem Rt1,Rt2,Rt3	bne RG3, R0, BROFF12	DBNOP	break	div RG2, RG3	mfhi RG1	#REMainder : Set Rt1 to (remainder of Rt2 divided by Rt3)
rem Rt1,Rt2,-100	addi R1, R0, VL3	div RG2, R1	mfhi RG1	#REMainder : Set Rt1 to (remainder of Rt2 divided by 16-bit immediate)
rem Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	div RG2, R1	mfhi RG1	#REMainder : Set Rt1 to (remainder of Rt2 divided by 32-bit immediate)
remu Rt1,Rt2,Rt3	bne RG3, R0, BROFF12	DBNOP	break	divu RG2, RG3	mfhi RG1	#REMainder : Set Rt1 to (remainder of Rt2 divided by Rt3, unsigned division)
remu Rt1,Rt2,-100	addi R1, R0, VL3	divu RG2, R1	mfhi RG1	#REMainder : Set Rt1 to (remainder of Rt2 divided by 16-bit immediate, unsigned division)
remu Rt1,Rt2,100000	lui R1, VHL3	ori R1, R1, VL3U	divu RG2, R1	mfhi RG1	#REMainder : Set Rt1 to (remainder of Rt2 divided by 32-bit immediate, unsigned division)


#########################  load/store pseudo-ops start here  ##########################
#
#  Most of these simply provide a variety of convenient memory addressing modes for 
#  specifying load/store address.
#

li Rt1,-100	addiu RG1, R0, VL2	#Load Immediate : Set Rt1 to 16-bit immediate (sign-extended)
li Rt1,100	ori RG1, R0, VL2U	#Load Immediate : Set Rt1 to unsigned 16-bit immediate (zero-extended)
li Rt1,100000	lui R1, VHL2	ori RG1, R1, VL2U	#Load Immediate : Set Rt1 to 32-bit immediate

la Rt1,(Rt2)	addi RG1, RG3, 0	#Load Address : Set Rt1 to contents of Rt2
la Rt1,-100	addiu RG1, R0, VL2	#Load Address : Set Rt1 to 16-bit immediate (sign-extended) 
la Rt1,100	ori RG1, R0, VL2U	#Load Address : Set Rt1 to 16-bit immediate (zero-extended) 
la Rt1,100000	lui R1, VHL2	ori RG1, R1, VL2U	#Load Address : Set Rt1 to 32-bit immediate
la Rt1,100(Rt2)	ori R1, R0, VL2U	add RG1, RG4, R1	#Load Address : Set Rt1 to sum (of Rt2 and 16-bit immediate)
la Rt1,100000(Rt2)	lui R1, VHL2	ori R1, R1, VL2U	add RG1, RG4, R1	#Load Address : Set Rt1 to sum (of Rt2 and 32-bit immediate)
la Rt1,label	lui R1, LHL	ori RG1, R1, LL2U	COMPACT	addi RG1, R0, LL2	#Load Address : Set Rt1 to label's address
la Rt1,label(Rt2)	lui R1, LHL	ori R1, R1, LL2U	add RG1, RG4, R1	COMPACT	addi RG1, RG4, LL2	#Load Address : Set Rt1 to sum (of Rt2 and label's address)
la Rt1,label+100000	lui R1, LHPN	ori RG1, R1, LLPU	#Load Address : Set Rt1 to sum (of label's address and 32-bit immediate)
la Rt1,label+100000(Rt2)	lui R1, LHPN	ori R1, R1, LLPU	add RG1, RG6, R1	#Load Address : Set Rt1 to sum (of label's address, 32-bit immediate, and Rt2)

lw Rt1,(Rt2)	lw RG1,0(RG3)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,-100	lw RG1, VL2(R0)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,100	ori R1, R0, VL2U	lw RG1, 0(R1)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,100000	lui R1, VH2	lw RG1,VL2(R1)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lw RG1, 0(R1)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lw RG1, VL2(R1)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,label	lui R1, LH2	lw RG1, LL2(R1)	COMPACT	lw RG1, LL2(R0)	#Load Word : Set Rt1 to contents of memory word at label's address
lw Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lw RG1, LL2(R1)	COMPACT	lw RG1, LL2(RG4)	#Load Word : Set Rt1 to contents of effective memory word address
lw Rt1,label+100000	lui R1, LHPA	lw RG1, LLP(R1)	#Load Word : Set Rt1 to contents of effective memory word address 
lw Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lw RG1, LLP(R1)	#Load Word : Set Rt1 to contents of effective memory word address

sw Rt1,(Rt2)	sw RG1,0(RG3)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,-100	sw RG1, VL2(R0)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,100	ori R1, R0, VL2U	sw RG1, 0(R1)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,100000	lui R1, VH2	sw RG1,VL2(R1)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	sw RG1, 0(R1)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sw RG1, VL2(R1)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,label	lui R1, LH2	sw RG1, LL2(R1)	COMPACT	sw RG1, LL2(R0)	#Store Word : Store Rt1 contents into memory word at label's address
sw Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sw RG1, LL2(R1)	COMPACT	sw RG1, LL2(RG4)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,label+100000	lui R1, LHPA	sw RG1, LLP(R1)	#Store Word : Store Rt1 contents into effective memory word address
sw Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sw RG1, LLP(R1)	#Store Word : Store Rt1 contents into effective memory word address

lh Rt1,(Rt2)	lh RG1,0(RG3)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,-100	lh RG1, VL2(R0)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,100	ori R1, R0, VL2U	lh RG1, 0(R1)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,100000	lui R1, VH2	lh RG1,VL2(R1)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lh RG1, 0(R1)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lh RG1, VL2(R1)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,label	lui R1, LH2	lh RG1, LL2(R1)	COMPACT	lh RG1, LL2(R0)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lh RG1, LL2(R1)	COMPACT	lh RG1, LL2(RG4)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,label+100000	lui R1, LHPA	lh RG1, LLP(R1)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address
lh Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lh RG1, LLP(R1)	#Load Halfword : Set Rt1 to sign-extended 16-bit value from effective memory halfword address

sh Rt1,(Rt2)	sh RG1,0(RG3)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,-100	sh RG1, VL2(R0)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,100	ori R1, R0, VL2U	sh RG1, 0(R1)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,100000	lui R1, VH2	sh RG1,VL2(R1)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	sh RG1, 0(R1)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sh RG1, VL2(R1)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,label	lui R1, LH2	sh RG1, LL2(R1)	COMPACT	sh RG1, LL2(R0)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sh RG1, LL2(R1)	COMPACT	sh RG1, LL2(RG4)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,label+100000	lui R1, LHPA	sh RG1, LLP(R1)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address
sh Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sh RG1, LLP(R1)	#Store Halfword : Store the low-order 16 bits of Rt1 into the effective memory halfword address

lb Rt1,(Rt2)	lb RG1,0(RG3)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,-100	lb RG1, VL2(R0)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,100	ori R1, R0, VL2U	lb RG1, 0(R1)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,100000	lui R1, VH2	lb RG1,VL2(R1)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lb RG1, 0(R1)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lb RG1, VL2(R1)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,label	lui R1, LH2	lb RG1, LL2(R1)	COMPACT	lb RG1, LL2(R0)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lb RG1, LL2(R1)	COMPACT	lb RG1, LL2(RG4)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,label+100000	lui R1, LHPA	lb RG1, LLP(R1)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address
lb Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lb RG1, LLP(R1)	#Load Byte : Set Rt1 to sign-extended 8-bit value from effective memory byte address

sb Rt1,(Rt2)	sb RG1,0(RG3)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,-100	sb RG1, VL2(R0)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,100	ori R1, R0, VL2U	sb RG1, 0(R1)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,100000	lui R1, VH2	sb RG1,VL2(R1)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	sb RG1, 0(R1)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sb RG1, VL2(R1)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,label	lui R1, LH2	sb RG1, LL2(R1)	COMPACT	sb RG1, LL2(R0)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sb RG1, LL2(R1)	COMPACT	sb RG1, LL2(RG4)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,label+100000	lui R1, LHPA	sb RG1, LLP(R1)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address
sb Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sb RG1, LLP(R1)	#Store Byte : Store the low-order 8 bits of Rt1 into the effective memory byte address

lhu Rt1,(Rt2)	lhu RG1,0(RG3)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,-100	lhu RG1,VL2(R0)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,100	ori R1, R0, VL2U	lhu RG1, 0(R1)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,100000	lui R1, VH2	lhu RG1,VL2(R1)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lhu RG1, 0(R1)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lhu RG1, VL2(R1)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,label	lui R1, LH2	lhu RG1, LL2(R1)	COMPACT	lhu RG1, LL2(R0)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lhu RG1, LL2(R1)	COMPACT	lhu RG1, LL2(RG4)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,label+100000	lui R1, LHPA	lhu RG1, LLP(R1)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address
lhu Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lhu RG1, LLP(R1)	#Load Halfword Unsigned : Set Rt1 to zero-extended 16-bit value from effective memory halfword address

lbu Rt1,(Rt2)	lbu RG1,0(RG3)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,-100	lbu RG1,VL2(R0)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,100	ori R1, R0, VL2U	lbu RG1, 0(R1)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,100000	lui R1, VH2	lbu RG1,VL2(R1)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lbu RG1, 0(R1)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lbu RG1, VL2(R1)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,label	lui R1, LH2	lbu RG1, LL2(R1)	COMPACT	lbu RG1, LL2(R0)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lbu RG1, LL2(R1)	COMPACT	lbu RG1, LL2(RG4)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,label+100000	lui R1, LHPA	lbu RG1, LLP(R1)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address
lbu Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lbu RG1, LLP(R1)	#Load Byte Unsigned : Set Rt1 to zero-extended 8-bit value from effective memory byte address

lwl Rt1,(Rt2)	lwl RG1,0(RG3)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,-100	lwl RG1,VL2(R0)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,100	ori R1, R0, VL2U	lwl RG1, 0(R1)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,100000	lui R1, VH2	lwl RG1,VL2(R1)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lwl RG1, 0(R1)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lwl RG1, VL2(R1)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,label	lui R1, LH2	lwl RG1, LL2(R1)	COMPACT	lwl RG1, LL2(R0)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lwl RG1, LL2(R1)	COMPACT	lwl RG1, LL2(RG4)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,label+100000	lui R1, LHPA	lwl RG1, LLP(R1)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lwl RG1, LLP(R1)	#Load Word Left : Load from 1 to 4 bytes left-justified into Rt1, starting with effective memory byte address and continuing through the low-order byte of its word

swl Rt1,(Rt2)	swl RG1,0(RG3)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,-100	swl RG1,VL2(R0)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,100	ori R1, R0, VL2U	swl RG1, 0(R1)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,100000	lui R1, VH2	swl RG1,VL2(R1)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	swl RG1, 0(R1)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	swl RG1, VL2(R1)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,label	lui R1, LH2	swl RG1, LL2(R1)	COMPACT	swl RG1, LL2(R0)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	swl RG1, LL2(R1)	COMPACT	swl RG1, LL2(RG4)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,label+100000	lui R1, LHPA	swl RG1, LLP(R1)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	swl RG1, LLP(R1)	#Store Word Left : Store high-order 1 to 4 bytes of Rt1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word

lwr Rt1,(Rt2)	lwr RG1,0(RG3)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,-100	lwr RG1,VL2(R0)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,100	ori R1, R0, VL2U	lwr RG1, 0(R1)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,100000	lui R1, VH2	lwr RG1,VL2(R1)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	lwr RG1, 0(R1)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lwr RG1, VL2(R1)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,label	lui R1, LH2	lwr RG1, LL2(R1)	COMPACT	lwr RG1, LL2(R0)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lwr RG1, LL2(R1)	COMPACT	lwr RG1, LL2(RG4)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,label+100000	lui R1, LHPA	lwr RG1, LLP(R1)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lwr RG1, LLP(R1)	#Load Word Right : Load from 1 to 4 bytes right-justified into Rt1, starting with effective memory byte address and continuing through the high-order byte of its word

swr Rt1,(Rt2)	swr RG1,0(RG3)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,-100	swr RG1,VL2(R0)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,100	ori R1, R0, VL2U	swr RG1, 0	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,100000	lui R1, VH2	swr RG1,VL2(R1)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	swr RG1, 0(R1)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	swr RG1, VL2(R1)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,label	lui R1, LH2	swr RG1, LL2(R1)	COMPACT	swr RG1, LL2(R0)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	swr RG1, LL2(R1)	COMPACT	swr RG1, LL2(RG4)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,label+100000	lui R1, LHPA	swr RG1, LLP(R1)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	swr RG1, LLP(R1)	#Store Word Right : Store low-order 1 to 4 bytes of Rt1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address

ll Rt1,(Rt2)	ll RG1,0(RG3)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,-100	ll RG1,VL2(R0)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,100	ori R1, R0, VL2U	ll RG1, 0(R1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,100000	lui R1, VH2	ll RG1,VL2(R1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	ll RG1, 0(R1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	ll RG1, VL2(R1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,label	lui R1, LH2	ll RG1, LL2(R1)	COMPACT	ll RG1, LL2(R0)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	ll RG1, LL2(R1)	COMPACT	ll RG1, LL2(RG4)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,label+100000	lui R1, LHPA	ll RG1, LLP(R1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	ll RG1, LLP(R1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.

sc Rt1,(Rt2)	sc RG1,0(RG3)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,-100	sc RG1,VL2(R0)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,100	ori R1, R0, VL2U	sc RG1, 0(R1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,100000	lui R1, VH2	sc RG1,VL2(R1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,100(Rt2)	ori R1, R0, VL2U	addu R1, R1, RG4	sc RG1, 0(R1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sc RG1, VL2(R1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,label	lui R1, LH2	sc RG1, LL2(R1)	COMPACT	sc RG1, LL2(R0)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sc RG1, LL2(R1)	COMPACT	sc RG1, LL2(RG4)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,label+100000	lui R1, LHPA	sc RG1, LLP(R1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sc RG1, LLP(R1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.

# Unaligned and double loads and stores.  All the them require assembler to add a constant
# byte offset (from 1 to 4 bytes) to the given or calculated address.
# NOTE: I have abandoned the "accepted" expansion of immed16(Rreg) addressing form for the 
#       unaligned and double load/store pseudo-instructions because they produce what I consider 
#       incorrect results for immediate values at the upper edge of the signed 16-bit range 
#       (32765 through 32767).  The expansion of these pseudo's requires adding an additional 
#       byte offset (from 1 to 4 bytes) to the immediate value, which overflows the signed 16 
#       bit range and results in a large negative offset with no counterbalancing increment 
#       to the high order 16-bits.  Thus if the two pieces of unaligned data end up in different 
#       words, they are stored 64K bytes apart!  For example, the normal expansion of 
#       "usw R8,32767(R9)" would be "swl R8,-32766(R9)", "swr R8, 32767(R9)"  Both SPIM and
#       Britten's text do this but I consider it incorrect.  My compromise is the following:
#       since each of the expansion calls for two calculated offsets, one of which can possibly
#       overflow due to the addition but the other will not (because there is no addition),
#       I'll code the expansion to treat the at-risk calculated offset as 32-bits (it will generate
#       the lui and addu, which is unnecessary in almost every case but is always correct)
#       and the second as 16-bits.  I'll group all instructions for this addressing mode together.
# ulw Rt1,-100(Rt2)	lwl RG1, VL2P3(RG4)	lwr RG1, VL2(RG4)   -- used by SPIM but not me.
# usw Rt1,-100(Rt2)	swl RG1, VL2P3(RG4)	swr RG1, VL2(RG4)   -- used by SPIM but not me.

ulw Rt1,-100(Rt2)	lui R1, VH2P3	addu R1, R1, RG4	lwl RG1, VL2P3(R1)	lwr RG1, VL2(RG4)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulh Rt1,-100(Rt2)	lui R1, VH2P1	addu R1, R1, RG4	lb RG1, VL2P1(R1)	lbu R1, VL2(RG4)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulhu Rt1,-100(Rt2)	lui R1, VH2P1	addu R1, R1, RG4	lbu RG1, VL2P1(R1)	lbu R1, VL2(RG4)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ld Rt1,-100(Rt2)	lw RG1, VL2(RG4)	lui R1, VH2P4	addu R1, R1, RG4	lw NR1, VL2P4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory byte address
usw Rt1,-100(Rt2)	lui R1, VH2P3	addu R1, R1, RG4	swl RG1, VL2P3(R1)	swr RG1, VL2(RG4)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
ush Rt1,-100(Rt2)	sb RG1, VL2(RG4)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, VH2P1	addu R1, R1, RG4	sb RG1, VL2P1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
sd Rt1,-100(Rt2)	sw RG1, VL2(RG4)	lui R1, VH2P4	addu R1, R1, RG4	sw NR1, VL2P4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory byte address

# here are the remaining addressing modes, grouped by instruction.

ulw Rt1,100000	lui R1, VH2P3	lwl RG1, VL2P3(R1)	lui R1, VH2	lwr RG1, VL2(R1)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulw Rt1,label	lui R1, LH2P3	lwl RG1, LL2P3(R1)	lui R1, LH2	lwr RG1, LL2(R1)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulw Rt1,label+100000	lui R1, LHPAP3	lwl RG1, LLPP3(R1)	lui R1, LHPA	lwr RG1, LLP(R1)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulw Rt1,(Rt2)	lwl RG1, 3(RG3)	lwr RG1, 0(RG3)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulw Rt1,100000(Rt2)	lui R1, VH2P3	addu R1, R1, RG4	lwl RG1, VL2P3(R1)	lui R1, VH2	addu R1, R1, RG4	lwr RG1, VL2(R1)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulw Rt1,label(Rt2)	lui R1, LH2P3	addu R1, R1, RG4	lwl RG1, LL2P3(R1)	lui R1, LH2	addu R1, R1, RG4	lwr RG1, LL2(R1)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address
ulw Rt1,label+100000(Rt2)	lui R1, LHPAP3	addu R1, R1, RG6	lwl RG1, LLPP3(R1)	lui R1, LHPA	addu R1, R1, RG6	lwr RG1, LLP(R1)	#Unaligned Load Word : Set Rt1 to the 32 bits starting at effective memory byte address

ulh Rt1,100000	lui R1, VH2P1	lb RG1, VL2P1(R1)	lui R1, VH2	lbu R1, VL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh Rt1,label	lui R1, LH2P1	lb RG1, LL2P1(R1)	lui R1, LH2	lbu R1, LL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh Rt1,label+100000	lui R1, LHPAP1	lb RG1, LLPP1(R1)	lui R1, LHPA	lbu R1, LLP(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh Rt1,(Rt2)	lb RG1, 1(RG3)	lbu R1, 0(RG3)	sll RG1, RG1, 8	or RG1, RG1, R1		#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh Rt1,100000(Rt2)	lui R1, VH2P1	addu R1, R1, RG4	lb RG1, VL2P1(R1)	lui R1, VH2	addu R1, R1, RG4	lbu R1, VL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh Rt1,label(Rt2)	lui R1, LH2P1	addu R1, R1, RG4	lb RG1, LL2P1(R1)	lui R1, LH2	addu R1, R1, RG4	lbu R1, LL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh Rt1,label+100000(Rt2)	lui R1, LHPAP1	addu R1, R1, RG6	lb RG1, LLPP1(R1)	lui R1, LHPA	addu R1, R1, RG6	lbu R1, LLP(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, sign-extended, starting at effective memory byte address

ulhu Rt1,100000	lui R1, VH2P1	lbu RG1, VL2P1(R1)	lui R1, VH2	lbu R1, VL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu Rt1,label	lui R1, LH2P1	lbu RG1, LL2P1(R1)	lui R1, LH2	lbu R1, LL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu Rt1,label+100000	lui R1, LHPAP1	lbu RG1, LLPP1(R1)	lui R1, LHPA	lbu R1, LLP(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu Rt1,(Rt2)	lbu RG1, 1(RG3)	lbu R1, 0(RG3)	sll RG1, RG1, 8	or RG1, RG1, R1		#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu Rt1,100000(Rt2)	lui R1, VH2P1	addu R1, R1, RG4	lbu RG1, VL2P1(R1)	lui R1, VH2	addu R1, R1, RG4	lbu R1, VL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu Rt1,label(Rt2)	lui R1, LH2P1	addu R1, R1, RG4	lbu RG1, LL2P1(R1)	lui R1, LH2	addu R1, R1, RG4	lbu R1, LL2(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu Rt1,label+100000(Rt2)	lui R1, LHPAP1	addu R1, R1, RG6	lbu RG1, LLPP1(R1)	lui R1, LHPA	addu R1, R1, RG6	lbu R1, LLP(R1)	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Load Halfword : Set Rt1 to the 16 bits, zero-extended, starting at effective memory byte address

ld Rt1,100000	lui R1, VH2	lw RG1, VL2(R1)	lui R1, VH2P4	lw NR1, VL2P4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address
ld Rt1,label	lui R1, LH2	lw RG1, LL2(R1)	lui R1, LH2P4	lw NR1, LL2P4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address
ld Rt1,label+100000	lui R1, LHPA	lw RG1, LLP(R1)	lui R1, LHPAP4	lw NR1, LLPP4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address
ld Rt1,(Rt2)	lw RG1, 0(RG3)	lw NR1, 4(RG3)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address
ld Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lw RG1, VL2(R1)	lui R1, VH2P4	addu R1, R1, RG4	lw NR1, VL2P4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address
ld Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lw RG1, LL2(R1)	lui R1, LH2P4	addu R1, R1, RG4	lw NR1, LL2P4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address
ld Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lw RG1, LLP(R1)	lui R1, LHPAP4	addu R1, R1, RG6	lw NR1, LLPP4(R1)	#Load Doubleword : Set Rt1 and the next register to the 64 bits starting at effective memory word address

usw Rt1,100000	lui R1, VH2P3	swl RG1, VL2P3(R1)	lui R1, VH2	swr RG1, VL2(R1)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
usw Rt1,label	lui R1, LH2P3	swl RG1, LL2P3(R1)	lui R1, LH2	swr RG1, LL2(R1)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
usw Rt1,label+100000	lui R1, LHPAP3	swl RG1, LLPP3(R1)	lui R1, LHPA	swr RG1, LLP(R1)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
usw Rt1,(Rt2)	swl RG1, 3(RG3)	swr RG1, 0(RG3)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
usw Rt1,100000(Rt2)	lui R1, VH2P3	addu R1, R1, RG4	swl RG1, VL2P3(R1)	lui R1, VH2	addu R1, R1, RG4	swr RG1, VL2(R1)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
usw Rt1,label(Rt2)	lui R1, LH2P3	addu R1, R1, RG4	swl RG1, LL2P3(R1)	lui R1, LH2	addu R1, R1, RG4	swr RG1, LL2(R1)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address
usw Rt1,label+100000(Rt2)	lui R1, LHPAP3	addu R1, R1, RG6	swl RG1, LLPP3(R1)	lui R1, LHPA	addu R1, R1, RG6	swr RG1, LLP(R1)	#Unaligned Store Word : Store Rt1 contents into the 32 bits starting at effective memory byte address

ush Rt1,100000	lui R1, VH2	sb RG1, VL2(R1)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, VH2P1	sb RG1, VL2P1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
ush Rt1,label	lui R1, LH2	sb RG1, LL2(R1)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, LH2P1	sb RG1, LL2P1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
ush Rt1,label+100000	lui R1, LHPA	sb RG1, LLP(R1)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, LHPAP1	sb RG1, LLPP1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
ush Rt1,(Rt2)	sb RG1, 0(RG3)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	sb RG1, 1(RG3)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
ush Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sb RG1, VL2(R1)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, VH2P1	addu R1, R1, RG4	sb RG1, VL2P1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
ush Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sb RG1, LL2(R1)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, LH2P1	addu R1, R1, RG4	sb RG1, LL2P1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address
ush Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sb RG1, LLP(R1)	sll R1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, R1	lui R1, LHPAP1	addu R1, R1, RG6	sb RG1, LLPP1(R1)	srl R1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, R1	#Unaligned Store Halfword: Store low-order halfword Rt1 contents into the 16 bits starting at effective memory byte address

sd Rt1,100000	lui R1, VH2	sw RG1, VL2(R1)	lui R1, VH2P4	sw NR1, VL2P4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address
sd Rt1,label	lui R1, LH2	sw RG1, LL2(R1)	lui R1, LH2P4	sw NR1, LL2P4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address
sd Rt1,label+100000	lui R1, LHPA	sw RG1, LLP(R1)	lui R1, LHPAP4	sw NR1, LLPP4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address
sd Rt1,(Rt2)	sw RG1, 0(RG3)	sw NR1, 4(RG3)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address
sd Rt1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sw RG1, VL2(R1)	lui R1, VH2P4	addu R1, R1, RG4	sw NR1, VL2P4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address
sd Rt1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sw RG1, LL2(R1)	lui R1, LH2P4	addu R1, R1, RG4	sw NR1, LL2P4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address
sd Rt1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sw RG1, LLP(R1)	lui R1, LHPAP4	addu R1, R1, RG6	sw NR1, LLPP4(R1)	#Store Doubleword : Store contents of Rt1 and the next register to the 64 bits starting at effective memory word address

# load and store pseudo-instructions for floating point (coprocessor 1) registers

lwc1 Rf1,(Rt2)	lwc1 RG1,0(RG3)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,-100	lwc1 RG1,VL2(R0)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,100000	lui R1, VH2	lwc1 RG1,VL2(R1)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lwc1 RG1, VL2(R1)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,label	lui R1, LH2	lwc1 RG1, LL2(R1)	COMPACT	lwc1 RG1, LL2(R0)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lwc1 RG1, LL2(R1)	COMPACT	lwc1 RG1, LL2(RG4)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,label+100000	lui R1, LHPA	lwc1 RG1, LLP(R1)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address
lwc1 Rf1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lwc1 RG1, LLP(R1)	#Load Word Coprocessor 1 : Set Rf1 to 32-bit value from effective memory word address

ldc1 Rf2,(Rt2)	ldc1 RG1,0(RG3)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,-100	ldc1 RG1,VL2(R0)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,100000	lui R1, VH2	ldc1 RG1,VL2(R1)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	ldc1 RG1, VL2(R1)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,label	lui R1, LH2	ldc1 RG1, LL2(R1)	COMPACT	ldc1 RG1, LL2(R0)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	ldc1 RG1, LL2(R1)	COMPACT	ldc1 RG1, LL2(RG4)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,label+100000	lui R1, LHPA	ldc1 RG1, LLP(R1)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
ldc1 Rf2,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	ldc1 RG1, LLP(R1)	#Load Doubleword Coprocessor 1 : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address

swc1 Rf1,(Rt2)	swc1 RG1,0(RG3)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,-100	swc1 RG1,VL2(R0)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,100000	lui R1, VH2	swc1 RG1,VL2(R1)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	swc1 RG1, VL2(R1)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,label	lui R1, LH2	swc1 RG1, LL2(R1)	COMPACT	swc1 RG1, LL2(R0)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	swc1 RG1, LL2(R1)	COMPACT	swc1 RG1, LL2(RG4)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,label+100000	lui R1, LHPA	swc1 RG1, LLP(R1)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address
swc1 Rf1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	swc1 RG1, LLP(R1)	#Store Word Coprocessor 1 : Store 32-bit value from Rf1 to effective memory word address

sdc1 Rf2,(Rt2)	sdc1 RG1,0(RG3)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,-100	sdc1 RG1,VL2(R0)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,100000	lui R1, VH2	sdc1 RG1,VL2(R1)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sdc1 RG1, VL2(R1)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,label	lui R1, LH2	sdc1 RG1, LL2(R1)	COMPACT	sdc1 RG1, LL2(R0)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sdc1 RG1, LL2(R1)	COMPACT	sdc1 RG1, LL2(RG4)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,label+100000	lui R1, LHPA	sdc1 RG1, LLP(R1)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
sdc1 Rf2,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sdc1 RG1, LLP(R1)	#Store Doubleword Coprocessor 1 : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address

l.s Rf1,(Rt2)	lwc1 RG1,0(RG3)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,-100	lwc1 RG1,VL2(R0)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,100000	lui R1, VH2	lwc1 RG1,VL2(R1)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	lwc1 RG1, VL2(R1)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,label	lui R1, LH2	lwc1 RG1, LL2(R1)	COMPACT	lwc1 RG1, LL2(R0)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	lwc1 RG1, LL2(R1)	COMPACT	lwc1 RG1, LL2(RG4)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,label+100000	lui R1, LHPA	lwc1 RG1, LLP(R1)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address
l.s Rf1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	lwc1 RG1, LLP(R1)	#Load floating point Single precision : Set Rf1 to 32-bit value at effective memory word address

s.s Rf1,(Rt2)	swc1 RG1,0(RG3)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,-100	swc1 RG1,VL2(R0)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,100000	lui R1, VH2	swc1 RG1,VL2(R1)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	swc1 RG1, VL2(R1)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,label	lui R1, LH2	swc1 RG1, LL2(R1)	COMPACT	swc1 RG1, LL2(R0)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	swc1 RG1, LL2(R1)	COMPACT	swc1 RG1, LL2(RG4)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,label+100000	lui R1, LHPA	swc1 RG1, LLP(R1)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address
s.s Rf1,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	swc1 RG1, LLP(R1)	#Store floating point Single precision : Store 32-bit value from Rf1 to effective memory word address

l.d Rf2,(Rt2)	ldc1 RG1,0(RG3)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,-100	ldc1 RG1,VL2(R0)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,100000	lui R1, VH2	ldc1 RG1,VL2(R1)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	ldc1 RG1, VL2(R1)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,label	lui R1, LH2	ldc1 RG1, LL2(R1)	COMPACT	ldc1 RG1, LL2(R0)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	ldc1 RG1, LL2(R1)	COMPACT	ldc1 RG1, LL2(RG4)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,label+100000	lui R1, LHPA	ldc1 RG1, LLP(R1)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address
l.d Rf2,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	ldc1 RG1, LLP(R1)	#Load floating point Double precision : Set Rf2 and Rf3 register pair to 64-bit value at effective memory doubleword address

s.d Rf2,(Rt2)	sdc1 RG1,0(RG3)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,-100	sdc1 RG1,VL2(R0)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,100000	lui R1, VH2	sdc1 RG1,VL2(R1)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,100000(Rt2)	lui R1, VH2	addu R1, R1, RG4	sdc1 RG1, VL2(R1)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,label	lui R1, LH2	sdc1 RG1, LL2(R1)	COMPACT	sdc1 RG1, LL2(R0)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,label(Rt2)	lui R1, LH2	addu R1, R1, RG4	sdc1 RG1, LL2(R1)	COMPACT	sdc1 RG1, LL2(RG4)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,label+100000	lui R1, LHPA	sdc1 RG1, LLP(R1)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
s.d Rf2,label+100000(Rt2)	lui R1, LHPA	addu R1, R1, RG6	sdc1 RG1, LLP(R1)	#Store floating point Double precision : Store 64 bits from Rf2 and Rf3 register pair to effective memory doubleword address
